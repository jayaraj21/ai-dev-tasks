import type { PrismaPromise } from '@prisma/client';
import type { User, VideoAd } from 'wasp/entities';
import { HttpError, prisma } from 'wasp/server';
// Types are auto-generated by Wasp - these will be available after compilation
import type {
  CreateVideoAd,
  GenerateVideoAd,
  GetVideoAdsByUser,
  GetVideoAdById,
  DeleteVideoAd,
} from 'wasp/server/operations';
import { ensureArgsSchemaOrThrowHttpError } from '../server/validation';
import { SubscriptionStatus } from '../payment/plans';
import {
  createVideoAdInputSchema,
  generateVideoAdInputSchema,
  getVideoAdByIdInputSchema,
  deleteVideoAdInputSchema,
  type CreateVideoAdInput as CreateVideoAdInputType,
  type GenerateVideoAdInput as GenerateVideoAdInputType,
  type GetVideoAdByIdInput as GetVideoAdByIdInputType,
  type DeleteVideoAdInput as DeleteVideoAdInputType,
} from './validation';
import { generateVideoAd } from './videoGenerator';
import { deleteVideo } from './storageUtils';

function isUserSubscribed(user: User) {
  return (
    user.subscriptionStatus === SubscriptionStatus.Active ||
    user.subscriptionStatus === SubscriptionStatus.CancelAtPeriodEnd
  );
}

//#region Actions
type CreateVideoAdInput = CreateVideoAdInputType;

export const createVideoAd: CreateVideoAd<CreateVideoAdInput, VideoAd> = async (rawArgs, context) => {
  if (!context.user) {
    throw new HttpError(401, 'Only authenticated users are allowed to perform this operation');
  }

  const { title, prompt } = ensureArgsSchemaOrThrowHttpError(createVideoAdInputSchema, rawArgs);

  const videoAd = await context.entities.VideoAd.create({
    data: {
      title,
      script: prompt, // Store initial prompt, will be replaced with generated script
      status: 'pending',
      user: { connect: { id: context.user.id } },
    },
  });

  return videoAd;
};

type GenerateVideoAdInput = GenerateVideoAdInputType;

export const generateVideoAdAction: GenerateVideoAd<GenerateVideoAdInput, VideoAd> = async (rawArgs, context) => {
  if (!context.user) {
    throw new HttpError(401, 'Only authenticated users are allowed to perform this operation');
  }

  const { videoAdId } = ensureArgsSchemaOrThrowHttpError(generateVideoAdInputSchema, rawArgs);

  // Get the video ad and verify ownership
  const videoAd = await context.entities.VideoAd.findFirst({
    where: {
      id: videoAdId,
      user: {
        id: context.user.id,
      },
    },
  });

  if (!videoAd) {
    throw new HttpError(404, 'Video ad not found');
  }

  if (videoAd.status !== 'pending') {
    throw new HttpError(400, `Video ad is already ${videoAd.status}`);
  }

  // Check credits/subscription
  if (!isUserSubscribed(context.user)) {
    if (context.user.credits <= 0) {
      throw new HttpError(402, 'User has not paid or is out of credits');
    }
  }

  // Get the prompt from the script field (initial prompt)
  const prompt = videoAd.script || videoAd.title;

  // Update status to generating
  await context.entities.VideoAd.update({
    where: { id: videoAdId },
    data: { status: 'generating' },
  });

  try {
    // Generate video ad (this starts the process)
    const result = await generateVideoAd(prompt, context.user.id, videoAdId);

    // Update video ad with job ID and generated script
    const transactions: PrismaPromise<VideoAd | User>[] = [
      context.entities.VideoAd.update({
        where: { id: videoAdId },
        data: {
          fastWanJobId: result.fastWanJobId,
          script: result.script ? JSON.stringify(result.script) : null,
          status: 'generating',
        },
      }),
    ];

    // Decrement credits if not subscribed
    if (!isUserSubscribed(context.user)) {
      const decrementCredit = context.entities.User.update({
        where: { id: context.user.id },
        data: {
          credits: {
            decrement: 1,
          },
        },
      });
      transactions.push(decrementCredit);
    }

    await prisma.$transaction(transactions);

    // Return updated video ad
    const updatedVideoAd = await context.entities.VideoAd.findUnique({
      where: { id: videoAdId },
    });

    if (!updatedVideoAd) {
      throw new HttpError(500, 'Failed to update video ad');
    }

    return updatedVideoAd;
  } catch (error) {
    // Update status to failed on error
    await context.entities.VideoAd.update({
      where: { id: videoAdId },
      data: {
        status: 'failed',
        metadata: JSON.stringify({ error: error instanceof Error ? error.message : 'Unknown error' }),
      },
    });

    throw error;
  }
};

type GetVideoAdByIdInput = GetVideoAdByIdInputType;

export const getVideoAdById: GetVideoAdById<GetVideoAdByIdInput, VideoAd | null> = async (rawArgs, context) => {
  if (!context.user) {
    throw new HttpError(401, 'Only authenticated users are allowed to perform this operation');
  }

  const { videoAdId } = ensureArgsSchemaOrThrowHttpError(getVideoAdByIdInputSchema, rawArgs);

  const videoAd = await context.entities.VideoAd.findFirst({
    where: {
      id: videoAdId,
      user: {
        id: context.user.id,
      },
    },
  });

  return videoAd;
};

type DeleteVideoAdInput = DeleteVideoAdInputType;

export const deleteVideoAd: DeleteVideoAd<DeleteVideoAdInput, VideoAd> = async (rawArgs, context) => {
  if (!context.user) {
    throw new HttpError(401, 'Only authenticated users are allowed to perform this operation');
  }

  const { videoAdId } = ensureArgsSchemaOrThrowHttpError(deleteVideoAdInputSchema, rawArgs);

  // Get video ad first to check ownership and get storage keys
  const videoAd = await context.entities.VideoAd.findFirst({
    where: {
      id: videoAdId,
      user: {
        id: context.user.id,
      },
    },
  });

  if (!videoAd) {
    throw new HttpError(404, 'Video ad not found');
  }

  // Delete video from storage if it exists
  if (videoAd.videoUrl) {
    try {
      await deleteVideo(videoAd.videoUrl);
    } catch (error) {
      console.warn(`Failed to delete video from storage: ${videoAd.videoUrl}`, error);
      // Continue with database deletion even if storage deletion fails
    }
  }

  // Delete thumbnail if it exists
  if (videoAd.thumbnailUrl) {
    try {
      await deleteVideo(videoAd.thumbnailUrl);
    } catch (error) {
      console.warn(`Failed to delete thumbnail from storage: ${videoAd.thumbnailUrl}`, error);
    }
  }

  // Delete from database
  const deletedVideoAd = await context.entities.VideoAd.delete({
    where: {
      id: videoAdId,
    },
  });

  return deletedVideoAd;
};
//#endregion

//#region Queries
export const getVideoAdsByUser: GetVideoAdsByUser<void, VideoAd[]> = async (_args, context) => {
  if (!context.user) {
    throw new HttpError(401, 'Only authenticated users are allowed to perform this operation');
  }

  return context.entities.VideoAd.findMany({
    where: {
      user: {
        id: context.user.id,
      },
    },
    orderBy: {
      createdAt: 'desc',
    },
  });
};
//#endregion

